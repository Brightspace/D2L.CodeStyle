using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace D2L.CodeStyle.Analyzers.Immutability {
	[DiagnosticAnalyzer( LanguageNames.CSharp )]
	public sealed class TypeDeclarationImmutabilityAnalyzer : DiagnosticAnalyzer {

		public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(
			Diagnostics.ArraysAreMutable,
			Diagnostics.DelegateTypesPossiblyMutable,
			Diagnostics.DynamicObjectsAreMutable,
			Diagnostics.EventMemberMutable,
			Diagnostics.MemberIsNotReadOnly,
			Diagnostics.NonImmutableTypeHeldByImmutable,
			Diagnostics.TypeParameterIsNotKnownToBeImmutable,
			Diagnostics.UnexpectedMemberKind,
			Diagnostics.UnexpectedTypeKind,
			Diagnostics.UnnecessaryMutabilityAnnotation
		);

		public override void Initialize( AnalysisContext context ) {
			context.EnableConcurrentExecution();
			context.RegisterCompilationStartAction( CompilationStart );
		}

		public static void CompilationStart(
			CompilationStartAnalysisContext context
		) {
			ImmutabilityContext immutabilityContext = ImmutabilityContext.Create( context.Compilation );

			context.RegisterSymbolAction(
				ctx => AnalyzeTypeDeclaration(
					ctx,
					immutabilityContext,
					(INamedTypeSymbol)ctx.Symbol
				),
				SymbolKind.NamedType
			);

			context.RegisterSymbolAction(
				ctx => AnalyzeMember( ctx, immutabilityContext ),
				SymbolKind.Field,
				SymbolKind.Property
			);
		}

		private static void AnalyzeMember(
			SymbolAnalysisContext ctx,
			ImmutabilityContext immutabilityContext
		) {
			// We only care about checking static fields/properties. These
			// are global variables, so we always want them to be immutable.
			// The fields/properties of [Immutable] types get handled via
			// AnalyzeTypeDeclaration.
			if ( !ctx.Symbol.IsStatic ) {
				return;
			}

			// Ignore const things, which include enum names.
			if ( ctx.Symbol is IFieldSymbol f && f.IsConst ) {
				return;
			}

			// We want to run our analyzer to run for generated code too, but
			// the generated code from resx files contain static variables
			// which don't contribute to mutability but can't be analyzed as
			// safe (e.g. CultureInfos, only some of those are read-only).
			if( IsFromGeneratedResourcesFile( ctx.Symbol ) ) {
				return;
			}

			var checker = new ImmutableDefinitionChecker(
				compilation: ctx.Compilation,
				diagnosticSink: ctx.ReportDiagnostic,
				context: immutabilityContext
			);

			checker.CheckMember( ctx.Symbol );
		}

		private static void AnalyzeTypeDeclaration(
			SymbolAnalysisContext ctx,
			ImmutabilityContext immutabilityContext,
			INamedTypeSymbol typeSymbol
		) {
			if( !ShouldAnalyze( typeSymbol ) ) {
				return;
			}

			ImmutableDefinitionChecker checker = new ImmutableDefinitionChecker(
				compilation: ctx.Compilation,
				diagnosticSink: ctx.ReportDiagnostic,
				context: immutabilityContext
			);

			checker.CheckDeclaration( typeSymbol );
		}

		private static bool ShouldAnalyze(
			INamedTypeSymbol analyzedType
		) {
			if( analyzedType.IsImplicitlyDeclared ) {
				return false;
			}

			if( analyzedType.TypeKind == TypeKind.Interface ) {
				return false;
			}

			if( Attributes.Objects.Immutable.IsDefined( analyzedType ) ) {
				return true;
			}

			if( Attributes.Objects.ImmutableBaseClass.IsDefined( analyzedType ) ) {
				return true;
			}

			return false;
		}

		private static bool IsFromGeneratedResourcesFile( ISymbol symbol ) {
			var tree = symbol.DeclaringSyntaxReferences.Single().SyntaxTree;

			return tree.FilePath.EndsWith( ".Designer.cs" )
				&& tree.ToString().StartsWith( "//------------------------------------------------------------------------------\n// <auto-generated>" );
		}
	}
}
